#pragma once
#include <array>
#include <cassert>
#include <vector>

#include "support/helpers.hpp"

namespace GPU {



 template <class T>
 concept Scalar = std::is_scalar<T>::value;

 template <Scalar T, size_t size>
 struct Vector {
   public:
     T& x() { return m_storage[0]; }
     T& y() { return m_storage[1]; }
     T& z() {
         static_assert(size >= 3, "Invalid Vector Access: Vector size < 3");
         return m_storage[2];
     }
     T& w() {
         static_assert(size >= 4, "Invalid Vector Access: Vector size < 4");
         return m_storage[3];
     }

     T& r() { return m_storage[0]; }
     T& g() { return m_storage[1]; }
     T& b() {
         static_assert(size >= 3, "Invalid Vector Access: Vector size < 3");
         return m_storage[2];
     }
     T& a() {
         static_assert(size >= 4, "Invalid Vector Access: Vector size < 4");
         return m_storage[3];
     }

     Vector() {}
     explicit Vector(std::array<T, size>& initlist) { std::copy(initlist.begin(), initlist.end(), &m_storage[0]); }

   private:
     static_assert(size >= 2 && size <= 4);
     T m_storage[size];
 };

 template <Scalar T>
 struct Rect {
     T x;
     T y;
     T w;
     T h;

     Rect() : x(0), y(0), w(0), h(0) {}
     Rect(T x, T y, T w, T h) : x(x), y(y), w(w), h(h) {}
 };

 struct DrawArea {
     u16 left;
     u16 top;
     u16 right;
     u16 bottom;
 };

 struct TextureWindow {
     u16 x;
     u16 y;
     u16 xMask;
     u16 yMask;
 };

 class GPU {
   public:
     GPU();
     ~GPU();

     void reset();

     u32 read0();
     u32 read1();

     void write0(u32 value);
     void write1(u32 value);

     static constexpr int VRAM_WIDTH = 1024;
     static constexpr int VRAM_HEIGHT = 512;
     static constexpr int VRAM_SIZE = VRAM_WIDTH * VRAM_HEIGHT;

   protected:
     enum TextureDepth { T4, T8, T16 };
     enum DisplayDepth { D15, D24 };
     enum DmaDirection { Off, Fifo, CputoGpu, GputoCpu };
     enum GP0Mode { Command, Transfer };

     void drawCommand();
     void writeInternal(u32 value);


     void setTextureWindow(u32 value);
     void setDrawOffset(u32 value);
     void setDrawAreaTopLeft(u32 value);
     void setDrawAreaBottomRight(u32 value);
     void setDrawMode(u32 value);

     u16 drawMode;
     u8 texPageX;
     u8 texPageY;
     u8 semiTrans;
     TextureDepth textureDepth;
     DisplayDepth displayDepth;
     bool dither;
     bool drawToDisplay;
     bool setMaskBit;
     bool preserveMaskedPixels;
     bool interlaced;
     bool disableDisplay;
     bool irq;
     DmaDirection dmaDirection;

     bool rectTextureFlipX;
     bool rectTextureFlipY;


     u32 gpustat;
     u32 gpuread;

     u8 command;
     u8 argsNeeded;
     u8 argsReceived;

     std::vector<u32> args;
     std::vector<u32> transferWriteBuffer;
     std::vector<u32> transferReadBuffer;
     std::vector<u16> vram;

     Rect<u16> transferRect;
     DrawArea drawArea;
     Rect<u16> drawOffset;
     TextureWindow texWindow;
     u32 transferSize;
     u32 transferIndex;



     u16 rectTexpage;
     bool commandPending = false;



     GP0Mode readMode = Command;
     GP0Mode writeMode = Command;

     // GPU Command Param LUT
     static constexpr int params[256] = {
         0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x03, 0x03, 0x06, 0x06, 0x06, 0x06, 0x04, 0x04, 0x04, 0x04,
         0x08, 0x08, 0x08, 0x08, 0x05, 0x05, 0x05, 0x05, 0x08, 0x08, 0x08, 0x08, 0x07, 0x07, 0x07, 0x07, 0x0B, 0x0B, 0x0B, 0x0B, 0x02, 0x02,
         0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x04, 0x04, 0x04, 0x04, 0x05, 0x05, 0x05, 0x05, 0x03, 0x03, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00,
         0x06, 0x06, 0x06, 0x06, 0x08, 0x08, 0x08, 0x08, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x03, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00,
         0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x03,
         0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
         0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
         0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
         0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
         0x02, 0x02, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     };
 };

}  // namespace GPU
